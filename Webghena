â€core/index.ts

â€core/intelligence.ts

â€core/security.ts

â€core/utils.ts

â€/package-lock.json

â€/package.json

â€quick-multi-play-intnetspace

â€export class CoreIntelligence {
â€  private aiName: string;
â€  private capabilities: string[];
â€  private processingQueue: any[];
â€  private isInitialized: boolean;

â€  constructor() {
â€    this.aiName = 'Ù…Ø§Ø±';
â€    this.capabilities = [
      'ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª',
      'Ø§ØªØ®Ø§Ø° Ø§Ù„Ù‚Ø±Ø§Ø±Ø§Øª',
      'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…ÙˆØ§Ø±Ø¯',
      'Ø§Ù„ØªØ­Ø³ÙŠÙ† Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ',
      'Ø§Ù„ØªØ¹Ù„Ù… Ø§Ù„Ø¢Ù„ÙŠ'
    ];
â€    this.processingQueue = [];
â€    this.isInitialized = false;
  }

â€  public initialize(): void {
â€    console.log(`ğŸ¤– [${this.aiName}] Ø¨Ø¯Ø¡ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ...`);
    
â€    // Simulate AI initialization
â€    setTimeout(() => {
â€      this.isInitialized = true;
â€      console.log(`âœ… [${this.aiName}] Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø¬Ø§Ù‡Ø² Ù„Ù„Ø¹Ù…Ù„`);
â€      console.log(`ğŸ“‹ Ø§Ù„Ù‚Ø¯Ø±Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©: ${this.capabilities.join(', ')}`);
    }, 2000);
  }

â€  public async processRequest(requestData: any): Promise<any> {
â€    if (!this.isInitialized) {
â€      throw new Error('Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ØºÙŠØ± Ù…Ù‡ÙŠØ£ Ø¨Ø¹Ø¯');
    }

â€    const requestId = this.generateRequestId();
â€    console.log(`ğŸ”„ [${this.aiName}] Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨: ${requestId}`);

â€    // Add to processing queue
â€    this.processingQueue.push({
â€      id: requestId,
â€      data: requestData,
â€      timestamp: new Date().toISOString(),
â€      status: 'processing'
    });

â€    // Simulate AI processing
â€    await this.simulateProcessing();

â€    const result = {
â€      requestId,
â€      aiName: this.aiName,
â€      processedAt: new Date().toISOString(),
â€      result: this.analyzeRequest(requestData),
â€      recommendations: this.generateRecommendations(requestData),
â€      confidence: this.calculateConfidence(requestData)
    };

â€    // Update queue status
â€    const queueItem = this.processingQueue.find(item => item.id === requestId);
â€    if (queueItem) {
â€      queueItem.status = 'completed';
â€      queueItem.result = result;
    }

â€    console.log(`âœ… [${this.aiName}] Ø§ÙƒØªÙ…Ù„ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø·Ù„Ø¨: ${requestId}`);
â€    return result;
  }

â€  private analyzeRequest(data: any): any {
â€    const analysis = {
â€      type: this.detectRequestType(data),
â€      complexity: this.assessComplexity(data),
â€      priority: this.determinePriority(data),
â€      estimatedTime: this.estimateProcessingTime(data)
    };

â€    return {
â€      analysis,
â€      insights: this.generateInsights(data),
â€      patterns: this.detectPatterns(data)
    };
  }

â€  private detectRequestType(data: any): string {
â€    if (data.action) {
â€      switch (data.action) {
â€        case 'create': return 'Ø¥Ù†Ø´Ø§Ø¡';
â€        case 'update': return 'ØªØ­Ø¯ÙŠØ«';
â€        case 'delete': return 'Ø­Ø°Ù';
â€        case 'analyze': return 'ØªØ­Ù„ÙŠÙ„';
â€        default: return 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';
      }
    }
â€    return 'Ø·Ù„Ø¨ Ø¹Ø§Ù…';
  }

â€  private assessComplexity(data: any): 'Ù…Ù†Ø®ÙØ¶' | 'Ù…ØªÙˆØ³Ø·' | 'Ø¹Ø§Ù„ÙŠ' {
â€    const dataSize = JSON.stringify(data).length;
    
â€    if (dataSize < 1000) return 'Ù…Ù†Ø®ÙØ¶';
â€    if (dataSize < 5000) return 'Ù…ØªÙˆØ³Ø·';
â€    return 'Ø¹Ø§Ù„ÙŠ';
  }

â€  private determinePriority(data: any): 'Ù…Ù†Ø®ÙØ¶' | 'Ù…ØªÙˆØ³Ø·' | 'Ø¹Ø§Ù„ÙŠ' | 'Ø­Ø±Ø¬' {
â€    if (data.urgent === true) return 'Ø­Ø±Ø¬';
â€    if (data.priority === 'high') return 'Ø¹Ø§Ù„ÙŠ';
â€    if (data.priority === 'medium') return 'Ù…ØªÙˆØ³Ø·';
â€    return 'Ù…Ù†Ø®ÙØ¶';
  }

â€  private estimateProcessingTime(data: any): string {
â€    const complexity = this.assessComplexity(data);
    
â€    switch (complexity) {
â€      case 'Ù…Ù†Ø®ÙØ¶': return '< 1 Ø«Ø§Ù†ÙŠØ©';
â€      case 'Ù…ØªÙˆØ³Ø·': return '1-5 Ø«ÙˆØ§Ù†ÙŠ';
â€      case 'Ø¹Ø§Ù„ÙŠ': return '5-30 Ø«Ø§Ù†ÙŠØ©';
â€      default: return 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';
    }
  }

â€  private generateInsights(data: any): string[] {
â€    const insights: string[] = [];
    
â€    if (data.timestamp) {
â€      const requestTime = new Date(data.timestamp);
â€      const now = new Date();
â€      const delay = now.getTime() - requestTime.getTime();
      
â€      if (delay > 5000) {
â€        insights.push('Ø§Ù„Ø·Ù„Ø¨ Ù‚Ø¯ÙŠÙ… Ù†Ø³Ø¨ÙŠØ§Ù‹ØŒ Ù‚Ø¯ ÙŠØ­ØªØ§Ø¬ Ù…Ø±Ø§Ø¬Ø¹Ø©');
      }
    }

â€    if (data.user) {
â€      insights.push(`Ø·Ù„Ø¨ Ù…Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: ${data.user}`);
    }

â€    if (Object.keys(data).length > 10) {
â€      insights.push('Ø·Ù„Ø¨ Ù…Ø¹Ù‚Ø¯ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª ÙƒØ«ÙŠØ±Ø©');
    }

â€    return insights;
  }

â€  private detectPatterns(data: any): string[] {
â€    const patterns: string[] = [];
    
â€    // Pattern detection logic
â€    if (data.action && data.target) {
â€      patterns.push(`Ù†Ù…Ø· Ø§Ù„Ø¹Ù…Ù„: ${data.action} Ø¹Ù„Ù‰ ${data.target}`);
    }

â€    if (data.repeated === true) {
â€      patterns.push('Ø·Ù„Ø¨ Ù…ØªÙƒØ±Ø±');
    }

â€    return patterns;
  }

â€  private generateRecommendations(data: any): string[] {
â€    const recommendations: string[] = [];
    
â€    const complexity = this.assessComplexity(data);
â€    if (complexity === 'Ø¹Ø§Ù„ÙŠ') {
â€      recommendations.push('ÙŠÙÙ†ØµØ­ Ø¨ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø·Ù„Ø¨ Ø¥Ù„Ù‰ Ø£Ø¬Ø²Ø§Ø¡ Ø£ØµØºØ±');
    }

â€    if (!data.validation) {
â€      recommendations.push('Ø¥Ø¶Ø§ÙØ© Ø¢Ù„ÙŠØ© Ø§Ù„ØªØ­Ù‚Ù‚ Ù„Ù„Ø¨ÙŠØ§Ù†Ø§Øª');
    }

â€    if (!data.backup) {
â€      recommendations.push('Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ù‚Ø¨Ù„ Ø§Ù„ØªÙ†ÙÙŠØ°');
    }

â€    return recommendations;
  }

â€  private calculateConfidence(data: any): number {
â€    let confidence = 0.5; // Base confidence
    
â€    // Increase confidence based on data completeness
â€    if (data.action) confidence += 0.1;
â€    if (data.target) confidence += 0.1;
â€    if (data.user) confidence += 0.1;
â€    if (data.timestamp) confidence += 0.1;
    
â€    // Adjust based on data quality
â€    const hasValidStructure = typeof data === 'object' && data !== null;
â€    if (hasValidStructure) confidence += 0.1;
    
â€    return Math.min(confidence, 1.0);
  }

â€  private async simulateProcessing(): Promise<void> {
â€    // Simulate processing time
â€    const processingTime = Math.random() * 1000 + 500; // 0.5-1.5 seconds
â€    return new Promise(resolve => setTimeout(resolve, processingTime));
  }

â€  private generateRequestId(): string {
â€    const timestamp = Date.now().toString(36);
â€    const random = Math.random().toString(36).substring(2);
â€    return `${timestamp}-${random}`;
  }

â€  public getStatus(): any {
â€    return {
â€      aiName: this.aiName,
â€      initialized: this.isInitialized,
â€      capabilities: this.capabilities,
â€      queueSize: this.processingQueue.length,
â€      activeRequests: this.processingQueue.filter(item => item.status === 'processing').length
    };
  }

â€  public getQueue(): any[] {
â€    return this.processingQueue.map(item => ({
â€      id: item.id,
â€      timestamp: item.timestamp,
â€      status: item.status
    }));
  }
}


â€server/index.ts


â€import React, { useRef, useEffect, useCallback } from 'react';
â€import { useGameStore } from '@/lib/stores/useGameStore';
â€import { useChallengeStore } from '@/lib/stores/useChallengeStore';
â€import { GAME_CONFIG } from '@shared/gameTypes';
â€import { clampPosition, checkCollision, getDistance } from '@/lib/gameLogic';

â€interface ChallengeGameCanvasProps {
â€  width: number;
â€  height: number;
}

â€export default function ChallengeGameCanvas({ width, height }: ChallengeGameCanvasProps) {
â€  const canvasRef = useRef<HTMLCanvasElement>(null);
â€  const animationFrameRef = useRef<number>();
â€  const { players, dots, playerId, movePlayer } = useGameStore();
â€  const { 
â€    currentChallenge, 
â€    isInChallenge, 
â€    challengeStartTime, 
â€    challengeScore, 
â€    challengeData,
â€    updateChallengeScore,
â€    updateChallengeData,
â€    endChallenge
â€  } = useChallengeStore();

â€  // Handle mouse/touch input
â€  const handlePointerMove = useCallback((e: React.PointerEvent) => {
â€    if (!canvasRef.current || !isInChallenge) return;
    
â€    const rect = canvasRef.current.getBoundingClientRect();
â€    const scaleX = GAME_CONFIG.CANVAS_WIDTH / rect.width;
â€    const scaleY = GAME_CONFIG.CANVAS_HEIGHT / rect.height;
    
â€    const x = (e.clientX - rect.left) * scaleX;
â€    const y = (e.clientY - rect.top) * scaleY;
    
â€    const clamped = clampPosition(x, y, GAME_CONFIG.CANVAS_WIDTH, GAME_CONFIG.CANVAS_HEIGHT);
    
â€    // Apply challenge-specific movement restrictions
â€    if (currentChallenge?.type === 'survival') {
â€      const centerX = GAME_CONFIG.CANVAS_WIDTH / 2;
â€      const centerY = GAME_CONFIG.CANVAS_HEIGHT / 2;
â€      const currentRadius = calculateSurvivalRadius();
â€      const distanceFromCenter = getDistance(clamped.x, clamped.y, centerX, centerY);
      
â€      if (distanceFromCenter > currentRadius) {
â€        // Clamp to survival area boundary
â€        const angle = Math.atan2(clamped.y - centerY, clamped.x - centerX);
â€        clamped.x = centerX + Math.cos(angle) * currentRadius;
â€        clamped.y = centerY + Math.sin(angle) * currentRadius;
      }
    }
    
â€    movePlayer(clamped.x, clamped.y);
â€  }, [movePlayer, isInChallenge, currentChallenge]);

â€  const calculateSurvivalRadius = useCallback(() => {
â€    if (!currentChallenge || !challengeStartTime || currentChallenge.type !== 'survival') {
â€      return GAME_CONFIG.CANVAS_WIDTH / 2;
    }
    
â€    const elapsed = (Date.now() - challengeStartTime) / 1000;
â€    const config = currentChallenge.config;
â€    const startRadius = config.startRadius || 250;
â€    const shrinkRate = config.shrinkRate || 15;
    
â€    return Math.max(50, startRadius - (elapsed * shrinkRate));
â€  }, [currentChallenge, challengeStartTime]);

â€  // Check challenge-specific conditions
â€  const checkChallengeConditions = useCallback(() => {
â€    if (!currentChallenge || !isInChallenge || !challengeStartTime) return;
    
â€    const currentPlayer = players.get(playerId || '');
â€    if (!currentPlayer) return;
    
â€    const elapsed = (Date.now() - challengeStartTime) / 1000;
    
â€    switch (currentChallenge.type) {
â€      case 'speedRun': {
â€        const dotsCollected = challengeData.dotsCollected || 0;
â€        const target = currentChallenge.config.dotsToCollect || 20;
        
â€        if (dotsCollected >= target) {
â€          updateChallengeScore(Math.floor((target * 1000) / elapsed));
â€          endChallenge(true);
â€        } else if (elapsed >= (currentChallenge.config.timeLimit || 60)) {
â€          endChallenge(false);
        }
â€        break;
      }
      
â€      case 'colorMatch': {
â€        const misses = challengeData.misses || 0;
â€        const maxMisses = currentChallenge.config.maxMisses || 3;
        
â€        if (misses >= maxMisses) {
â€          endChallenge(false);
â€        } else if (challengeScore >= (currentChallenge.config.targetScore || 15)) {
â€          endChallenge(true);
        }
â€        break;
      }
      
â€      case 'avoidance': {
â€        const misses = challengeData.misses || 0;
â€        const maxMisses = currentChallenge.config.maxMisses || 1;
        
â€        if (misses >= maxMisses) {
â€          endChallenge(false);
â€        } else if (challengeScore >= (currentChallenge.config.targetScore || 25)) {
â€          endChallenge(true);
        }
â€        break;
      }
      
â€      case 'kingOfHill': {
â€        const config = currentChallenge.config;
â€        const hillCenter = config.hillCenter || { x: 400, y: 300 };
â€        const hillRadius = config.hillRadius || 80;
â€        const pointsPerSecond = config.pointsPerSecond || 2;
        
â€        const inHill = getDistance(currentPlayer.x, currentPlayer.y, hillCenter.x, hillCenter.y) <= hillRadius;
        
â€        if (inHill) {
â€          const timeInHill = (challengeData.timeInHill || 0) + 0.016; // ~60fps
â€          updateChallengeData({ timeInHill });
â€          updateChallengeScore(Math.floor(timeInHill * pointsPerSecond));
        }
        
â€        if (challengeScore >= (config.targetScore || 100)) {
â€          endChallenge(true);
â€        } else if (elapsed >= (config.timeLimit || 90)) {
â€          endChallenge(challengeScore >= (config.targetScore || 100));
        }
â€        break;
      }
      
â€      case 'survival': {
â€        const centerX = GAME_CONFIG.CANVAS_WIDTH / 2;
â€        const centerY = GAME_CONFIG.CANVAS_HEIGHT / 2;
â€        const currentRadius = calculateSurvivalRadius();
â€        const distanceFromCenter = getDistance(currentPlayer.x, currentPlayer.y, centerX, centerY);
        
â€        if (distanceFromCenter > currentRadius) {
â€          endChallenge(false);
â€        } else {
â€          updateChallengeScore(Math.floor(elapsed * 10));
          
â€          if (elapsed >= (currentChallenge.config.timeLimit || 120)) {
â€            endChallenge(true);
          }
        }
â€        break;
      }
      
â€      case 'relay': {
â€        const checkpoints = currentChallenge.config.checkpoints || [];
â€        const currentCheckpoint = challengeData.currentCheckpoint || 0;
        
â€        if (currentCheckpoint < checkpoints.length) {
â€          const checkpoint = checkpoints[currentCheckpoint];
â€          const distance = getDistance(currentPlayer.x, currentPlayer.y, checkpoint.x, checkpoint.y);
          
â€          if (distance <= 25) {
â€            const newCheckpoint = currentCheckpoint + 1;
â€            updateChallengeData({ currentCheckpoint: newCheckpoint });
            
â€            if (newCheckpoint >= checkpoints.length) {
â€              updateChallengeScore(Math.floor((checkpoints.length * 1000) / elapsed));
â€              endChallenge(true);
            }
          }
        }
        
â€        if (elapsed >= (currentChallenge.config.timeLimit || 90)) {
â€          endChallenge(false);
        }
â€        break;
      }
      
â€      case 'precision': {
â€        // Precision targets are handled via click events
â€        if (elapsed >= (currentChallenge.duration || 120)) {
â€          const targets = currentChallenge.config.targets || [];
â€          const hits = challengeData.hits || 0;
â€          endChallenge(hits >= targets.length);
        }
â€        break;
      }
    }
â€  }, [currentChallenge, isInChallenge, challengeStartTime, challengeData, challengeScore, players, playerId, updateChallengeScore, updateChallengeData, endChallenge, calculateSurvivalRadius]);

â€  // Handle dot collection for challenges
â€  const handleDotCollection = useCallback((dot: any, player: any) => {
â€    if (!currentChallenge || !isInChallenge) return false;
    
â€    let shouldCollect = true;
â€    let points = dot.points;
    
â€    switch (currentChallenge.type) {
â€      case 'speedRun': {
â€        const dotsCollected = (challengeData.dotsCollected || 0) + 1;
â€        updateChallengeData({ dotsCollected });
â€        break;
      }
      
â€      case 'colorMatch': {
â€        const allowedColors = currentChallenge.config.allowedColors || [];
â€        const forbiddenColors = currentChallenge.config.forbiddenColors || [];
        
â€        if (forbiddenColors.includes(dot.color) || (allowedColors.length > 0 && !allowedColors.includes(dot.color))) {
â€          const misses = (challengeData.misses || 0) + 1;
â€          updateChallengeData({ misses });
â€          shouldCollect = false;
â€          points = 0;
        }
â€        break;
      }
      
â€      case 'avoidance': {
â€        const forbiddenColors = currentChallenge.config.forbiddenColors || ['#ff4444'];
        
â€        if (forbiddenColors.includes(dot.color)) {
â€          const misses = (challengeData.misses || 0) + 1;
â€          updateChallengeData({ misses });
â€          shouldCollect = false;
â€          points = 0;
        }
â€        break;
      }
      
â€      case 'treasure': {
â€        if (dot.color === '#FFD700') { // Golden dot
â€          points = currentChallenge.config.treasurePoints || 10;
        }
â€        break;
      }
    }
    
â€    if (shouldCollect && points > 0) {
â€      updateChallengeScore(challengeScore + points);
    }
    
â€    return shouldCollect;
â€  }, [currentChallenge, isInChallenge, challengeData, challengeScore, updateChallengeData, updateChallengeScore]);

â€  // Custom rendering for challenge modes
â€  const renderChallengeElements = useCallback((ctx: CanvasRenderingContext2D) => {
â€    if (!currentChallenge || !isInChallenge) return;
    
â€    switch (currentChallenge.type) {
â€      case 'kingOfHill': {
â€        const config = currentChallenge.config;
â€        const hillCenter = config.hillCenter || { x: 400, y: 300 };
â€        const hillRadius = config.hillRadius || 80;
        
â€        // Draw hill area
â€        ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
â€        ctx.beginPath();
â€        ctx.arc(hillCenter.x, hillCenter.y, hillRadius, 0, Math.PI * 2);
â€        ctx.fill();
        
â€        ctx.strokeStyle = '#FFD700';
â€        ctx.lineWidth = 3;
â€        ctx.stroke();
        
â€        // Draw "KING OF HILL" text
â€        ctx.fillStyle = '#B8860B';
â€        ctx.font = 'bold 16px Arial';
â€        ctx.textAlign = 'center';
â€        ctx.fillText('KING OF HILL', hillCenter.x, hillCenter.y);
â€        break;
      }
      
â€      case 'survival': {
â€        const centerX = GAME_CONFIG.CANVAS_WIDTH / 2;
â€        const centerY = GAME_CONFIG.CANVAS_HEIGHT / 2;
â€        const currentRadius = calculateSurvivalRadius();
        
â€        // Draw safe area
â€        ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';
â€        ctx.beginPath();
â€        ctx.arc(centerX, centerY, currentRadius, 0, Math.PI * 2);
â€        ctx.fill();
        
â€        // Draw danger zone
â€        ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
â€        ctx.fillRect(0, 0, GAME_CONFIG.CANVAS_WIDTH, GAME_CONFIG.CANVAS_HEIGHT);
        
â€        // Cut out safe area
â€        ctx.globalCompositeOperation = 'destination-out';
â€        ctx.beginPath();
â€        ctx.arc(centerX, centerY, currentRadius, 0, Math.PI * 2);
â€        ctx.fill();
â€        ctx.globalCompositeOperation = 'source-over';
        
â€        // Draw border
â€        ctx.strokeStyle = '#ff4444';
â€        ctx.lineWidth = 4;
â€        ctx.beginPath();
â€        ctx.arc(centerX, centerY, currentRadius, 0, Math.PI * 2);
â€        ctx.stroke();
â€        break;
      }
      
â€      case 'relay': {
â€        const checkpoints = currentChallenge.config.checkpoints || [];
â€        const currentCheckpoint = challengeData.currentCheckpoint || 0;
        
â€        checkpoints.forEach((checkpoint, index) => {
â€          const isActive = index === currentCheckpoint;
â€          const isCompleted = index < currentCheckpoint;
          
â€          ctx.fillStyle = isCompleted ? '#22c55e' : isActive ? '#3b82f6' : '#94a3b8';
â€          ctx.beginPath();
â€          ctx.arc(checkpoint.x, checkpoint.y, 20, 0, Math.PI * 2);
â€          ctx.fill();
          
â€          ctx.fillStyle = 'white';
â€          ctx.font = 'bold 14px Arial';
â€          ctx.textAlign = 'center';
â€          ctx.fillText((index + 1).toString(), checkpoint.x, checkpoint.y + 5);
        });
â€        break;
      }
      
â€      case 'precision': {
â€        const targets = currentChallenge.config.targets || [];
â€        const hits = challengeData.hits || 0;
        
â€        targets.forEach((target, index) => {
â€          const isHit = index < hits;
          
â€          ctx.strokeStyle = isHit ? '#22c55e' : '#ef4444';
â€          ctx.lineWidth = 3;
â€          ctx.beginPath();
â€          ctx.arc(target.x, target.y, target.radius, 0, Math.PI * 2);
â€          ctx.stroke();
          
â€          if (!isHit) {
â€            ctx.strokeStyle = '#ef4444';
â€            ctx.lineWidth = 2;
â€            ctx.beginPath();
â€            ctx.moveTo(target.x - 10, target.y - 10);
â€            ctx.lineTo(target.x + 10, target.y + 10);
â€            ctx.moveTo(target.x + 10, target.y - 10);
â€            ctx.lineTo(target.x - 10, target.y + 10);
â€            ctx.stroke();
â€          } else {
â€            ctx.fillStyle = '#22c55e';
â€            ctx.font = 'bold 16px Arial';
â€            ctx.textAlign = 'center';
â€            ctx.fillText('âœ“', target.x, target.y + 6);
          }
        });
â€        break;
      }
    }
â€  }, [currentChallenge, isInChallenge, challengeData, calculateSurvivalRadius]);

â€  // Handle precision target clicks
â€  const handleCanvasClick = useCallback((e: React.MouseEvent) => {
â€    if (!currentChallenge || currentChallenge.type !== 'precision' || !isInChallenge) return;
    
â€    const rect = canvasRef.current?.getBoundingClientRect();
â€    if (!rect) return;
    
â€    const scaleX = GAME_CONFIG.CANVAS_WIDTH / rect.width;
â€    const scaleY = GAME_CONFIG.CANVAS_HEIGHT / rect.height;
    
â€    const x = (e.clientX - rect.left) * scaleX;
â€    const y = (e.clientY - rect.top) * scaleY;
    
â€    const targets = currentChallenge.config.targets || [];
â€    const hits = challengeData.hits || 0;
    
â€    if (hits < targets.length) {
â€      const target = targets[hits];
â€      const distance = getDistance(x, y, target.x, target.y);
      
â€      if (distance <= target.radius) {
â€        const newHits = hits + 1;
â€        updateChallengeData({ hits: newHits });
â€        updateChallengeScore(challengeScore + 10);
        
â€        if (newHits >= targets.length) {
â€          endChallenge(true);
        }
â€      } else {
â€        const misses = (challengeData.misses || 0) + 1;
â€        updateChallengeData({ misses });
        
â€        const penalty = currentChallenge.config.penaltyPerMiss || 10;
â€        updateChallengeScore(Math.max(0, challengeScore - penalty));
        
â€        if (misses >= (currentChallenge.config.maxMisses || 2)) {
â€          endChallenge(false);
        }
      }
    }
â€  }, [currentChallenge, isInChallenge, challengeData, challengeScore, updateChallengeData, updateChallengeScore, endChallenge]);

â€  // Main render function
â€  const render = useCallback(() => {
â€    const canvas = canvasRef.current;
â€    if (!canvas) return;
    
â€    const ctx = canvas.getContext('2d');
â€    if (!ctx) return;

â€    // Clear canvas
â€    ctx.fillStyle = '#f0f0f0';
â€    ctx.fillRect(0, 0, GAME_CONFIG.CANVAS_WIDTH, GAME_CONFIG.CANVAS_HEIGHT);

â€    // Draw grid pattern
â€    ctx.strokeStyle = '#e0e0e0';
â€    ctx.lineWidth = 1;
â€    const gridSize = 50;
â€    for (let x = 0; x <= GAME_CONFIG.CANVAS_WIDTH; x += gridSize) {
â€      ctx.beginPath();
â€      ctx.moveTo(x, 0);
â€      ctx.lineTo(x, GAME_CONFIG.CANVAS_HEIGHT);
â€      ctx.stroke();
    }
â€    for (let y = 0; y <= GAME_CONFIG.CANVAS_HEIGHT; y += gridSize) {
â€      ctx.beginPath();
â€      ctx.moveTo(0, y);
â€      ctx.lineTo(GAME_CONFIG.CANVAS_WIDTH, y);
â€      ctx.stroke();
    }

â€    // Render challenge-specific elements
â€    renderChallengeElements(ctx);

â€    // Draw dots (with challenge-specific modifications)
â€    dots.forEach(dot => {
â€      let dotColor = dot.color;
      
â€      // Special rendering for treasure hunt
â€      if (currentChallenge?.type === 'treasure' && dot.color === '#FFD700') {
â€        // Make treasure dots sparkle
â€        const time = Date.now() / 1000;
â€        const sparkle = Math.sin(time * 4) * 0.3 + 0.7;
â€        ctx.save();
â€        ctx.globalAlpha = sparkle;
        
â€        // Draw larger golden dot
â€        ctx.fillStyle = '#FFD700';
â€        ctx.beginPath();
â€        ctx.arc(dot.x, dot.y, GAME_CONFIG.DOT_SIZE * 0.8, 0, Math.PI * 2);
â€        ctx.fill();
        
â€        // Draw sparkle effect
â€        ctx.strokeStyle = '#FFF700';
â€        ctx.lineWidth = 2;
â€        const sparkleSize = 8;
â€        ctx.beginPath();
â€        ctx.moveTo(dot.x - sparkleSize, dot.y);
â€        ctx.lineTo(dot.x + sparkleSize, dot.y);
â€        ctx.moveTo(dot.x, dot.y - sparkleSize);
â€        ctx.lineTo(dot.x, dot.y + sparkleSize);
â€        ctx.stroke();
        
â€        ctx.restore();
â€      } else {
â€        ctx.fillStyle = dotColor;
â€        ctx.beginPath();
â€        ctx.arc(dot.x, dot.y, GAME_CONFIG.DOT_SIZE / 2, 0, Math.PI * 2);
â€        ctx.fill();
      }
      
â€      // Draw points value
â€      ctx.fillStyle = '#333';
â€      ctx.font = '12px Arial';
â€      ctx.textAlign = 'center';
â€      ctx.fillText(dot.points.toString(), dot.x, dot.y - GAME_CONFIG.DOT_SIZE);
    });

â€    // Draw players
â€    const playersArray = Array.from(players.values());
â€    playersArray.forEach(player => {
â€      // Player circle
â€      ctx.fillStyle = player.color;
â€      ctx.beginPath();
â€      ctx.arc(player.x, player.y, GAME_CONFIG.PLAYER_SIZE / 2, 0, Math.PI * 2);
â€      ctx.fill();
      
â€      // Player border
â€      ctx.strokeStyle = player.id === playerId ? '#fff' : '#333';
â€      ctx.lineWidth = player.id === playerId ? 3 : 2;
â€      ctx.stroke();
      
â€      // Player name
â€      ctx.fillStyle = '#333';
â€      ctx.font = 'bold 14px Arial';
â€      ctx.textAlign = 'center';
â€      ctx.fillText(player.name, player.x, player.y - GAME_CONFIG.PLAYER_SIZE);
    });

â€    // Check challenge conditions each frame
â€    checkChallengeConditions();

â€    animationFrameRef.current = requestAnimationFrame(render);
â€  }, [players, dots, playerId, currentChallenge, isInChallenge, challengeData, renderChallengeElements, checkChallengeConditions]);

â€  useEffect(() => {
â€    if (isInChallenge) {
â€      render();
    }
    
â€    return () => {
â€      if (animationFrameRef.current) {
â€        cancelAnimationFrame(animationFrameRef.current);
      }
    };
â€  }, [render, isInChallenge]);

â€  if (!isInChallenge) {
â€    return null;
  }

â€  return (
â€    <canvas
â€      ref={canvasRef}
â€      width={GAME_CONFIG.CANVAS_WIDTH}
â€      height={GAME_CONFIG.CANVAS_HEIGHT}
â€      className="border border-gray-300 rounded-lg cursor-crosshair touch-none"
â€      style={{ 
â€        width: width,
â€        height: height,
â€        maxWidth: '100%',
â€        maxHeight: '100%'
      }}
â€      onPointerMove={handlePointerMove}
â€      onPointerEnter={handlePointerMove}
â€      onClick={handleCanvasClick}
    />
  );
}



2. Ø´ØºÙ‘Ù„ ÙƒÙ„ Ø®Ø¯Ù…Ø© ÙÙŠ Ù†Ø§ÙØ°Ø© Ù…Ù†ÙØµÙ„Ø© (ÙŠÙØ¶Ù„ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù†ÙˆØ§Ø© Ø£ÙˆÙ„Ø§Ù‹):

- **Ø§Ù„Ù†ÙˆØ§Ø© Ø§Ù„Ù…Ø±ÙƒØ²ÙŠØ© (CoreAI):**
  ```
â€     cd core
â€     npm start
  ```

- **Ø¨ÙˆØ§Ø¨Ø© Ø§Ù„Ù†Ø¸Ø§Ù… (API Gateway):**
  ```
â€     cd api
â€     npm start
  ```

- **Ø®Ø¯Ù…Ø© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª:**
  ```
â€     cd services/products
â€     npm start
  ```

- **ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (Next.js):**
  ```
â€     cd frontend/web
â€     npm run dev
  ```

3. Ù„Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ù…Ù†ØµØ©:
- Ø§ÙØªØ­ Ø§Ù„Ù…ØªØµÙØ­ Ø¹Ù„Ù‰:
  ```
â€     http://localhost:3000/
  ```
- Ø³ØªØ´Ø§Ù‡Ø¯ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙˆØ¹Ù†ÙˆØ§Ù† Ø§Ù„Ù…Ù†ØµØ©.


â€2. Ø´ØºÙ‘Ù„ ÙƒÙ„ Ø®Ø¯Ù…Ø© ÙÙŠ Ù†Ø§ÙØ°Ø© Ù…Ù†ÙØµÙ„Ø© (ÙŠÙØ¶Ù„ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù†ÙˆØ§Ø© Ø£ÙˆÙ„Ø§Ù‹):

â€- **Ø§Ù„Ù†ÙˆØ§Ø© Ø§Ù„Ù…Ø±ÙƒØ²ÙŠØ© (CoreAI):**
  ```
â€â€     cd core
â€â€     npm start
  ```

â€- **Ø¨ÙˆØ§Ø¨Ø© Ø§Ù„Ù†Ø¸Ø§Ù… (API Gateway):**
  ```
â€â€     cd api
â€â€     npm start
  ```

â€- **Ø®Ø¯Ù…Ø© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª:**
  ```
â€â€     cd services/products
â€â€     npm start
  ```

â€- **ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (Next.js):**
  ```
â€â€     cd frontend/web
â€â€     npm run dev
  ```

â€3. Ù„Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ù…Ù†ØµØ©:
â€- Ø§ÙØªØ­ Ø§Ù„Ù…ØªØµÙØ­ Ø¹Ù„Ù‰:
  ```
â€â€     http://localhost:3000/
